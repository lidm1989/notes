# **算法**

# BST 二叉搜索树
二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于有 n 个结点的一棵完全二叉树来说，这些操作的最坏运行时间为 O(logN)。然而，如果这棵树是一条 n 个结点组成的线性链，那么同样的操作就要花费 O(N) 的最坏运行时间。

平衡二叉搜索树

### RB-tree
红黑树是一种平衡二叉树，搜索的时间复杂度为 O(logN)。
C++ STL 中的 map 实现基于 RB-tree。

### AVL-tree

# 2-3 树

# 2-3-4 树
最简单的 B 树

# B 树 (B-tree)
与红黑树相比，尽管二者的高度都以 O(logN) 增长，但对 B 树来说，对数的底可以大很多倍。

# B+ 树
一个常见的 B 树变种，称为 B+ 树，它把所有的卫星数据都存储在叶结点中，内部结点只存放关键字和孩子指针，因此最大化了内部结点的分支因子。

# B* 树
另一个常见的 B 树变种称为 B* 树，它要求每个内部结点至少是 2/3 满的，而不像 B 树要求的至少是半满的。

# hash table
散列表最优情况下搜索的时间复杂度为O(1)。

散列冲突是散列技术与生俱来的问题，有很多方法可以用来解决散列冲突问题，比如开链法、开放定址法。
Python 中的 dict 就使用开放定址法。

# 一致性算法
节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。
    raft
    paxos
    totem







